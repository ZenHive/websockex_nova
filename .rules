# WebsockexNew Rules

In financial software development, especially for market making, there's a well-established principle: **start simple, add complexity only when necessary based on real data**.

## Code Optimization Guidelines

- **All Elixir code files must balance token optimization with readability**

  - **Module Documentation**: Use concise, structured `@moduledoc` with clear bullet points for key components
  - **Function Documentation**: Optimize `@doc` blocks with a single-sentence summary followed by structured details
  - **Code Organization**: Optimize code structure for both machine and human comprehension

  - **DO (Optimized Documentation):**

    ```elixir
    @moduledoc """
    WebSocket client for real-time cryptocurrency trading APIs.

    - Uses Gun transport for WebSocket connections
    - Handles automatic reconnection with exponential backoff
    - Supports message routing and frame handling
    """

    @doc """
    Connects to WebSocket endpoint with configuration options.

    Returns client struct for subsequent operations.
    """
    ```

  - **DON'T (Verbose Documentation):**

    ```elixir
    @moduledoc """
    This module provides a comprehensive WebSocket client implementation
    specifically designed for cryptocurrency trading platforms. It offers
    robust connection management, automatic reconnection capabilities,
    and efficient message handling for real-time market data streaming.
    """

    @doc """
    Establishes a WebSocket connection to the specified endpoint URL.

    This function creates a new WebSocket connection using the Gun HTTP client
    as the underlying transport mechanism. It accepts various configuration
    options to customize the connection behavior including timeouts, headers,
    and reconnection settings.
    """
    ```

  - **DO (Optimized Code Structure):**

    ```elixir
    # Group related functions together
    # Use clear naming conventions
    # Optimize function parameter patterns
    def connect(%Config{url: url} = config, opts \\ []) do
      timeout = config.timeout
      headers = config.headers

      with {:ok, gun_pid} <- open_connection(url, opts),
           {:ok, stream_ref} <- upgrade_to_websocket(gun_pid, headers),
           :ok <- await_websocket_upgrade(gun_pid, stream_ref, timeout) do
        {:ok, %Client{gun_pid: gun_pid, stream_ref: stream_ref, state: :connected}}
      else
        error -> {:error, error}
      end
    end

    defp open_connection(url, opts), do: Gun.open(url, opts)

    defp upgrade_to_websocket(gun_pid, headers) do
      Gun.ws_upgrade(gun_pid, "/", headers)
    end
    ```

  - **DON'T (Suboptimal Code Structure):**

    ```elixir
    # Functions scattered without logical grouping
    # Unclear naming or verbosity
    # Repetitive code or complex conditionals
    def establish_websocket_connection_with_configuration(configuration_parameters, additional_options \\ []) do
      parsed_configuration = parse_and_validate_configuration(configuration_parameters)
      connection_timeout = get_configuration_value(parsed_configuration, :connection_timeout, 5000)
      connection_headers = get_configuration_value(parsed_configuration, :connection_headers, [])

      case attempt_gun_connection_establishment(parsed_configuration.websocket_url, additional_options) do
        {:ok, gun_connection_process_id} ->
          websocket_upgrade_headers = prepare_websocket_upgrade_headers(connection_headers)
          
          case attempt_websocket_protocol_upgrade(gun_connection_process_id, websocket_upgrade_headers) do
            {:ok, websocket_stream_reference} ->
              connection_established = wait_for_websocket_upgrade_completion(gun_connection_process_id, websocket_stream_reference, connection_timeout)
              
              if connection_established do
                {:ok, construct_client_state_struct(gun_connection_process_id, websocket_stream_reference)}
              else
                {:error, :websocket_upgrade_timeout}
              end
            
            {:error, upgrade_error} ->
              {:error, {:websocket_upgrade_failed, upgrade_error}}
          end

        {:error, connection_error} ->
          {:error, {:connection_failed, connection_error}}
      end
    end
    ```

- **Rationale:**
  - Reduces token usage and cognitive load while maintaining clarity
  - Improves code maintainability and review efficiency
  - Aligns code documentation with existing machine-readable documentation standards
  - Speeds up AI tools' understanding of code patterns and intent
  - Reduces error likelihood by favoring clear, consistent patterns

## Integration Testing Requirements

- **Core Principles**:

  - Test with REAL WebSocket APIs (NO mocks for WebSocket responses)
  - Verify end-to-end functionality across component boundaries
  - Test behavior under realistic conditions (network latency, connection drops)
  - Document all test scenarios thoroughly

- **Test Structure**:

  - ✅ **DO**: Use real dependencies and document test scenarios

    ```elixir
    @tag :integration
    test "maintains subscriptions across reconnection", %{deribit_config: config} do
      # Use real Deribit testnet connection (no mocks)
      {:ok, client} = WebsockexNew.Client.connect(config.url, config.opts)

      # Subscribe to real market data
      {:ok, _} = WebsockexNew.Client.subscribe(client, ["book.BTC-PERPETUAL.raw"])
      
      # Simulate connection drop
      Process.exit(client.gun_pid, :kill)
      
      # Verify reconnection and subscription restoration
      wait_for_reconnection(client)
      assert_subscription_active(client, "book.BTC-PERPETUAL.raw")
    end
    ```

  - ❌ **DON'T**: Use mocks or oversimplified scenarios

    ```elixir
    # Bad: Using mocks instead of real WebSocket connections
    test "maintains subscriptions across reconnection" do
      mock_client = MockWebSocket.new()
      MockWebSocket.expect(mock_client, :subscribe, fn _, _ -> {:ok, :subscribed} end)
      MockWebSocket.expect(mock_client, :reconnect, fn _ -> {:ok, :reconnected} end)

      {:ok, _} = WebsockexNew.Client.subscribe(mock_client, ["book.BTC-PERPETUAL.raw"])
      MockWebSocket.simulate_disconnect(mock_client)
      assert MockWebSocket.reconnected?(mock_client)
    end
    ```

- **Test Environment Requirements**:

  - Use real WebSocket testnets (test.deribit.com) for realistic testing
  - Tag integration tests with `@tag :integration`
  - Create helper modules in `test/support/` for setup
  - Ensure tests run both locally and in CI

- **Scenario Coverage Required**:

  - Happy path functionality (connect, send, subscribe, close)
  - Error cases with real error conditions (timeouts, auth failures, malformed frames)
  - Edge cases (network volatility, server outages, concurrent operations)
  - Reconnection scenarios with state preservation

- **Documentation Requirements**:

  - Document all scenarios in test files with clear descriptions
  - Include setup requirements and preconditions
  - Explain expected outcomes and verification points
  - Update documentation when modifying integration tests

- **Example Test Structure**:

  ```elixir
  defmodule WebsockexNew.Integration.ConnectionTest do
    use WebsockexNew.Integration.TestCase

    @tag :integration
    test "handles real network interruption gracefully", %{deribit_config: config} do
      # 1. Connect to real Deribit testnet
      {:ok, client} = WebsockexNew.Client.connect(config.url, config.opts)

      # 2. Verify initial connection works
      assert client.state == :connected

      # 3. Simulate network interruption
      Process.exit(client.gun_pid, :kill)

      # 4. Verify automatic reconnection
      wait_for_reconnection(client)
      assert client.state == :connected
    end
  end
  ```

## Simplicity Guidelines

- **Foundational Principles**:

  - Code simplicity is a primary feature, not an afterthought
  - Implement the minimal viable solution first
  - Each component has a limited "complexity budget"
  - Create abstractions only with proven value (≥2 concrete examples)
  - Start simple and add complexity incrementally
  - Prioritize execution and practical operational efficiency
  - Deliberately simplify solutions wherever possible, reducing overhead and maintenance costs

- **Module Structure Limits for WebsockexNew**:

  - Maximum 8 modules total in main library (already achieved)
  - Maximum 5 functions per module initially
  - Maximum function length of 15 lines
  - Maximum of 2 levels of function calls for any operation
  - Choose the right tool: pure functions for stateless operations, GenServers for stateful/concurrent needs

- **Code Structure Guidelines**:

  - ✅ **DO**: Keep modules and functions small and focused

    ```elixir
    # Simple, single-responsibility function
    @spec validate_config(map()) :: {:ok, Config.t()} | {:error, String.t()}
    def validate_config(params) when is_map(params) do
      with {:ok, _} <- validate_required_fields(params),
           {:ok, _} <- validate_url_format(params) do
        {:ok, struct(Config, params)}
      else
        {:error, reason} -> {:error, reason}
      end
    end
    ```

  - ❌ **DON'T**: Create complex abstractions prematurely

    ```elixir
    # Overly abstract, complex pattern with speculative functionality
    defmodule ComplexWebSocketBehavior do
      @callback connect(term()) :: {:ok, term()} | {:error, term()}
      @callback send_message(term(), term()) :: {:ok, term()} | {:error, term()}
      # Many other callbacks for hypothetical future needs
    end

    defmodule WebSocketRegistry do
      # Complex registry for connections that aren't needed yet
    end
    ```

- **Process and State Management**:

  - ✅ **DO**: Use GenServer when you need to receive messages or manage state

    ```elixir
    # GenServer is appropriate when receiving Gun messages
    defmodule WebsockexNew.Client do
      use GenServer
      
      def handle_info({:gun_ws, gun_pid, stream_ref, frame}, state) do
        # Process incoming WebSocket frames
        {:noreply, process_frame(state, frame)}
      end
    end
    
    # ETS is good for shared state without message handling
    def register_connection(client_id, gun_pid) do
      :ets.insert(:websockex_connections, {client_id, gun_pid, :os.timestamp()})
    end
    ```

  - ❌ **DON'T**: Avoid processes when they genuinely simplify the solution
    ```elixir
    # Don't use complex workarounds to avoid GenServer
    # when GenServer is the natural solution
    defmodule AvoidingGenServerUnnecessarily do
      # Complex polling or callback mechanisms
      # when a simple GenServer would suffice
    end
    ```

- **Technology Selection Guidelines**:

  - Use GenServers when you need:
    - To receive messages (like Gun WebSocket frames)
    - Maintain state across operations
    - Coordinate concurrent access
    - Implement supervision/fault tolerance
  - Use ETS for:
    - Shared state without message handling
    - High-performance lookups
    - Cache-like functionality
  - Use pure functions for:
    - Stateless transformations
    - Simple calculations
    - Data validation

- **Anti-Patterns to Avoid**:
  - No premature optimization without performance data
  - No "just-in-case" code for hypothetical requirements
  - No abstractions without at least 2 concrete usage examples
  - No complex macros unless absolutely necessary
  - No overly clever solutions that prioritize elegance over maintainability

"The elegance comes from doing less, not more. Removing complexity, not adding it!"

## WebSocket Connection Architecture

- **Connection Model**:

  - WebSocket connections are Gun processes managed by WebsockexNew.Client
  - Connection processes are monitored, not owned by complex supervisors
  - Failures detected by `Process.monitor/1` and classified by exit reasons

- **Reconnection API Requirements**:

  - ✅ **DO**: Follow the established reconnection workflow

    ```elixir
    # Public API with reconnection capability
    {:ok, client} = WebsockexNew.Client.connect(url, [
      timeout: 5000,
      retry_count: 3,
      retry_delay: 1000,
      heartbeat_interval: 30000
    ])
    ```

  - ❌ **DON'T**: Implement custom reconnection logic outside the framework
    ```elixir
    # Don't create custom reconnection loops
    def custom_reconnect(url, options) do
      case WebsockexNew.Client.connect(url, options) do
        {:ok, client} -> {:ok, client}
        {:error, _} ->
          Process.sleep(1000)
          custom_reconnect(url, options)
      end
    end
    ```

- **Error Classification**:

  - WebSocket errors should be identified by pattern matching on Gun errors
  - Network errors should be distinguished from protocol/frame errors
  - Error content must provide sufficient information for reconnection decisions

- **Connection Testing Requirements**:

  - Tests must reliably simulate network failures using real connections
  - Tests must handle asynchronous reconnection processes
  - Avoid fixed timing assumptions in tests

  ```elixir
  # Correct way to test reconnection
  @tag :integration
  test "reconnects automatically after connection loss", %{deribit_config: config} do
    {:ok, client} = WebsockexNew.Client.connect(config.url, config.opts)

    # Verify initial connection works
    assert client.state == :connected

    # Simulate connection loss
    Process.exit(client.gun_pid, :kill)

    # Wait for reconnection
    wait_for_reconnection(client)
    assert client.state == :connected
  end
  ```

- **Message Handling Architecture**

  - **Message Processing**:

    - Messages must use the existing `WebsockexNew.MessageHandler` module
    - Frame operations must emit telemetry events for monitoring
    - Callback patterns should be supported for user handlers

  - **Error Handling**:
    - Frame errors must pass through raw error data without wrapping
    - Use standard {:ok, result} | {:error, reason} pattern consistently
    - Follow the "let it crash" philosophy for unexpected errors
    - Protocol and network errors must be distinguishable by error content
    - Malformed frames must be cleanly handled with proper error reporting

## Error System Architecture

- **Core Principles**:

  - Pass raw errors without wrapping in custom structs
  - Use consistent {:ok, result} | {:error, reason} pattern
  - Apply "let it crash" philosophy for unexpected errors
  - Add minimal context information only when necessary

- **Error Handling Requirements**:

  - ✅ **DO**: Use pattern matching on raw error data

    ```elixir
    def handle_connection_error({:error, error}) do
      # Take action based on the raw error pattern
      case error do
        {:timeout, _duration} -> handle_timeout_error()
        {:connection_refused, _details} -> handle_connection_refused()
        {:protocol_error, frame_error} -> handle_frame_error(frame_error)
        _ -> {:error, :unknown_connection_error}
      end
    end
    ```

  - ❌ **DON'T**: Create custom error transformation logic

    ```elixir
    # Don't create custom transformation logic
    def handle_connection_error({:error, error}) do
      # This transforms errors unnecessarily
      error_type = classify_websocket_error(error)
      error_data = extract_error_metadata(error)

      # Transforms errors inconsistently
      case error_type do
        :timeout -> handle_timeout(error_data)
        :connection -> handle_connection_issue(error_data)
        _ -> {:error, :unknown_error}
      end
    end
    ```

- **Error Creation Guidelines**:

  - Return original Gun/WebSocket error data in {:error, reason} tuples
  - Include relevant connection information directly in the error value
  - Use consistent error formats across similar functions
  - For expected errors, create clear error atoms or tuples with data

- **Telemetry Integration**:
  - Error events should include original error values
  - Use consistent error metadata format in telemetry events
  - Emit error events when connection or frame errors are encountered

## TaskList.md Format Specification

```
# WebsockexNew Task List

## Development Status Update (Month Year)
### ✅ Recently Completed
- **WNX####**: [Task title] - [Brief description]
- **WNX####**: [Task title] - [Brief description]

### 🚀 Next Up
1. **WNX####**: [Task title] ([Priority] Priority)
2. **WNX####**: [Task title] ([Priority] Priority)

### 📊 Progress: [X]/[Y] tasks completed ([Z]%)

## WebSocket Client Architecture
[Architecture details specific to WebSocket client]

## Integration Test Setup Notes
[Brief integration testing reminders for WebSocket testing]

## Simplicity Guidelines for All Tasks
[Simplicity principles and requirements for WebSocket client]

## Current Tasks
| ID      | Description                    | Status  | Priority | Assignee | Review Rating |
| ------- | ------------------------------ | ------- | -------- | -------- | ------------- |
| WNX#### | [Task description]             | [Status]| [Priority]| [Assignee] |             |

## Implementation Order
[Ordered list of tasks with dependencies and explanations]

## Completed Tasks
| ID      | Description                    | Status    | Priority | Assignee | Review Rating |
| ------- | ------------------------------ | --------- | -------- | -------- | ------------- |
| WNX#### | [Task description]             | Completed | [Priority]| [Assignee] | ⭐⭐⭐⭐⭐    |

## Task Details

### WNX####: [Task Title] (✅ COMPLETED)
**Description**: [Detailed task description]

**Simplicity Progression Plan**:
1. [Step 1]
2. [Step 2]
3. [Step 3]
4. [Step 4]

**Simplicity Principle**:
[Brief description of the simplicity principle applied]

**Abstraction Evaluation**:
- **Challenge**: [Question about necessary abstraction]
- **Minimal Solution**: [Simplest viable solution]
- **Justification**:
  1. [Use case 1]
  2. [Use case 2]
  3. [Use case 3]

**Requirements**:
- [Requirement 1]
- [Requirement 2]
- [Requirement 3]

**ExUnit Test Requirements**:
- [Test requirement 1]
- [Test requirement 2]
- [Test requirement 3]

**Integration Test Scenarios**:
- [Test scenario 1]
- [Test scenario 2]
- [Test scenario 3]

**Typespec Requirements**:
- [Typespec requirement 1]
- [Typespec requirement 2]
- [Typespec requirement 3]

**TypeSpec Documentation**:
- [Documentation requirement 1]
- [Documentation requirement 2]
- [Documentation requirement 3]

**TypeSpec Verification**:
- [Verification step 1]
- [Verification step 2]
- [Verification step 3]

**Error Handling**
**Core Principles**
- Pass raw WebSocket/Gun errors
- Use {:ok, result} | {:error, reason}
- Let it crash for unexpected conditions

**Error Implementation**
- No wrapping of Gun errors
- Minimal rescue for expected failures
- Clear error categorization

**Error Examples**
- Raw Gun error passthrough
- Frame parsing error handling
- Connection monitoring patterns

**WebSocket Specifics**
- Frame error handling patterns
- Connection state management
- Monitor-based cleanup

**Status**: [Status]
**Priority**: [Priority]

**Implementation Notes**:
- [Implementation note 1]
- [Implementation note 2]
- [Implementation note 3]

**Complexity Assessment**:
- [Complexity assessment 1]
- [Complexity assessment 2]
- [Complexity assessment 3]

**Maintenance Impact**:
- [Maintenance impact 1]
- [Maintenance impact 2]
- [Maintenance impact 3]

**Error Handling Implementation**:
- [Error handling implementation 1]
- [Error handling implementation 2]
- [Error handling implementation 3]

### WNX####: [Task Title]
[Same structure as above for current/planned tasks]

## Implementation Notes
[General implementation notes and guidelines for WebSocket client]

## Platform Integration Notes
[Notes on integrating with cryptocurrency exchange platforms]
```

- **Required Fields and Values**

  - **ID Format**: `WNX####` (Regex: `WNX\d{4}`)

    - Core functionality: WNX0001-WNX0099
    - Feature enhancements: WNX0100-WNX0199
    - Documentation: WNX0200-WNX0299
    - Testing: WNX0300-WNX0399

  - **Status Values**:

    - `Planned`
    - `In Progress`
    - `Review`
    - `Completed`
    - `Blocked`

  - **Priority Values**:

    - `Critical`
    - `High`
    - `Medium`
    - `Low`

  - **Review Rating**:
    - Format: ⭐ stars (1-5) for visual representation
    - Alternatively: decimal number between 1.0-5.0

- **WebSocket-Specific Requirements**:
  - All WebSocket connection tasks must include real API testing requirements
  - Platform integration tasks should reference existing Deribit adapter patterns
  - Frame handling tasks must include malformed data testing scenarios
  - Reconnection tasks must test with real network interruption scenarios

- **Validation Rules**
  - All task IDs must be unique and use WNX prefix
  - All current tasks must have detailed entries
  - Completed tasks must have implementation notes and review ratings
  - WebSocket tasks must include connection testing requirements
  - Error handling sections must reference Gun/WebSocket error patterns